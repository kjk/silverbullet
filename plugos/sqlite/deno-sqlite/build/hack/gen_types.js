var Type = /* @__PURE__ */ ((Type2) => {
  Type2[Type2["Void"] = 0] = "Void";
  Type2[Type2["VoidPtr"] = 1] = "VoidPtr";
  Type2[Type2["StringPtr"] = 2] = "StringPtr";
  Type2[Type2["StatementPtr"] = 3] = "StatementPtr";
  Type2[Type2["Double"] = 4] = "Double";
  Type2[Type2["Int"] = 5] = "Int";
  return Type2;
})(Type || {});
const items = [
  {
    name: "malloc",
    arguments: [{ name: "size", type: 5 /* Int */ }],
    returnType: 1 /* VoidPtr */
  },
  {
    name: "free",
    arguments: [{ name: "ptr", type: 1 /* VoidPtr */ }],
    returnType: 0 /* Void */
  }
];
const [src, dest] = Deno.args;
const wrapperSrc = await Deno.readTextFile(src);
const typeRegexp = `(const +)?(sqlite3_stmt\\*|char\\*|void\\*|int|uint32_t|double|void)`;
const argRegexp = `${typeRegexp} +[a-z_]+`;
const exportSignature = new RegExp(
  `${typeRegexp} +EXPORT\\([a-z_]+\\) +\\(((${argRegexp}( *, *${argRegexp})*)|)\\)`
);
function nullThrows(value) {
  if (value == null) {
    throw new Error("Got a null value");
  }
  return value;
}
function typeFromCType(cType) {
  cType = cType.replace("const", "").replace(/ /g, "");
  switch (cType) {
    case "void":
      return 0 /* Void */;
    case "void*":
      return 1 /* VoidPtr */;
    case "char*":
      return 2 /* StringPtr */;
    case "sqlite3_stmt*":
      return 3 /* StatementPtr */;
    case "double":
      return 4 /* Double */;
    case "int":
    case "uint32_t":
      return 5 /* Int */;
    default:
      throw new Error("Unknown type");
  }
}
function getReturnType(line) {
  const regexp = new RegExp(typeRegexp);
  const [, _const, cType] = nullThrows(regexp.exec(line));
  return typeFromCType(cType);
}
function getName(line) {
  const [, name] = nullThrows(/EXPORT\(([a-z_]+)\)/.exec(line));
  return name;
}
function getArguments(line) {
  const [, argList] = nullThrows(/EXPORT\([a-z_]+\) *\(([^)]*)\)/.exec(line));
  if (argList.length === 0) {
    return [];
  } else {
    return argList.split(",").map((arg) => {
      const regexp = new RegExp(`${typeRegexp} +([a-z_]+)`);
      const [, _const, cType, name] = nullThrows(regexp.exec(arg));
      return {
        name,
        type: typeFromCType(cType)
      };
    });
  }
}
function generateType(tp) {
  switch (tp) {
    case 0 /* Void */:
      return "void";
    case 1 /* VoidPtr */:
      return "VoidPtr";
    case 2 /* StringPtr */:
      return "StringPtr";
    case 3 /* StatementPtr */:
      return "StatementPtr";
    case 5 /* Int */:
    case 4 /* Double */:
      return "number";
    default:
      throw new Error("Unknown type");
  }
}
function generateDecl(item) {
  const args = item.arguments.map(
    (arg) => `${arg.name}: ${generateType(arg.type)}`
  ).join(", ");
  return `${item.name}: (${args}) => ${generateType(item.returnType)}`;
}
const exportLines = wrapperSrc.split("\n").filter(
  (line) => exportSignature.test(line)
);
for (const line of exportLines) {
  const name = getName(line);
  const returnType = getReturnType(line);
  const args = getArguments(line);
  items.push({ name, returnType, arguments: args });
}
const typeDeclaration = `/* This file is automatically generated. Do not edit directly. */

export type VoidPtr = number;
export type StringPtr = number;
export type StatementPtr = number;

export interface Wasm {
  memory: WebAssembly.Memory;

  ${items.map(generateDecl).join(";\n  ")};
}

export function compile(): Promise<void>;
export function instantiateBrowser(): Promise<void>;
export function instantiate(): { exports: Wasm };
`;
await Deno.writeTextFile(dest, typeDeclaration);
